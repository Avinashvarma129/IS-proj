# -*- coding: utf-8 -*-
"""genetic_tsp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N6qjJLYiG8Phjv6UiRQ5KlxuJlE86JW_
"""

#Emmanuel Adebayo
#Traveling salesman problem
#genetic algorithm
#simulating the process of evolution to find the best possible route
import numpy as np
import matplotlib.pyplot as plt

def generate_population(pop_size, bs, es, random_route):
    bswap = bs
    eswap = es
    population = []
    population.append(random_route)
    for i in range(pop_size-1):
        to_shift = population[-1].copy()  # Create a copy to avoid modifying the original route
        shifted = shift(to_shift, bswap, eswap)
        population.append(shifted)
    return population

def shift(arr, start_idx, end_idx):
    if start_idx < 0 or start_idx >= len(arr) or end_idx < 0 or end_idx >= len(arr) or start_idx >= end_idx:
        # Check if the start and end indices are valid and in the correct order
        return arr

    element_to_move = arr[start_idx]

    for i in range(start_idx, end_idx):
        arr[i] = arr[i + 1]

    arr[end_idx] = element_to_move

    return arr

def fitness_score_each(chromosome, adj_mat):
  length = len(chromosome) - 1
  dist = 0
  for i in range(length):
    a = chromosome[i]
    b = chromosome[i+1]
    dist = dist + adj_mat[a-1][b-1]
    # print(adj_mat[a][b])

  return dist

def fitness_score_of_all_candiadte(population, adj_mat):
  score_dictionary = {}
  for chromosome in population:
    score = fitness_score_each(chromosome, adj_mat)
    score_dictionary[score] = chromosome

  return score_dictionary

import numpy as np

def crossover(route_1, route_2):
    # Ensure that the two input routes have the same length
    if len(route_1) != len(route_2):
        raise ValueError("Routes must have the same length for crossover.")

    # Choose a crossover point (index) for route crossover
    crossover_point = np.random.randint(1, len(route_1) - 1)

    # Perform crossover by swapping route segments between the two routes
    new_route_1 = route_1[:crossover_point] + [city for city in route_2 if city not in route_1[:crossover_point]] + [1]
    new_route_2 = route_2[:crossover_point] + [city for city in route_1 if city not in route_2[:crossover_point]] + [1]

    return new_route_1, new_route_2

# Example usage
route1 = [1, 2, 3, 4,6,8, 1]
route2 = [1, 4, 6,3,8, 2, 1]

new_route1, new_route2 = crossover(route1, route2)
print("New Route 1:", new_route1)
print("New Route 2:", new_route2)

def tsp_mutation(route):
    # Clone the original route to avoid modifying it directly
    mutated_route = route.copy()

    # Select two random indices for mutation
    index1, index2 = np.random.choice(range(1, len(route) - 1), size=2, replace=False)

    # Perform the mutation by swapping two cities in the route
    mutated_route[index1], mutated_route[index2] = mutated_route[index2], mutated_route[index1]

    return mutated_route

# Example usage
original_route = [1, 2, 3, 4, 5, 1]
mutated_route = tsp_mutation(original_route)
print("Original Route:", original_route)
print("Mutated Route:", mutated_route)

adjacency_matrix = np.array([
    [0,10,15,20],
    [5,0,9,10],
    [6,13,0,12],
    [8,8,9,0]
])

initial_route = [1,4,3,2,1]

total_dist = fitness_score_each(initial_route, adjacency_matrix)

begin_shift = 1
end_shift = len(initial_route) - 2
initial_pop_size = len(initial_route) - 2

answer = []
popul = generate_population(initial_pop_size, begin_shift, end_shift, initial_route)

print(popul)
for i in range(10):

  score_dict = fitness_score_of_all_candiadte(popul,adjacency_matrix)
  print("score dict", score_dict)
  smallest_key = min(score_dict.keys())
  # fittest = score_dict[smallest_key]
  lowest_keys = sorted(score_dict.keys())[:2]
  fittest_one = score_dict[lowest_keys[0]]
  fittest_two = score_dict[lowest_keys[1]]
  popul = []
  popul.append(fittest_one)
  popul.append(fittest_two)

  crossover_1, crossover_2 = crossover(fittest_one, fittest_two)
  popul.append(crossover_1)
  popul.append(crossover_2)

  mutation_of_fittest_one = tsp_mutation(fittest_one)
  mutation_of_fittest_two = tsp_mutation(fittest_two)

  popul.append(mutation_of_fittest_one)
  popul.append(mutation_of_fittest_two)

  print("fittest_one", fittest_one,"fittest two", fittest_two)
  print(score_dict)
  answer = fittest_one
  # initial_pop_size = initial_pop_size - 1
  # print(popul)

print("answer",answer)



import numpy as np
import matplotlib.pyplot as plt

def plot_solution(coords, mat, solution):
    plt.scatter(coords[:, 0], coords[:, 1])
    n = len(coords)

    for idx in range(n-1):
        i, next_i = solution[idx] - 1, solution[idx+1] - 1
        plt.plot([coords[i, 0], coords[next_i, 0]], [coords[i, 1], coords[next_i, 1]], c='blue', lw=1, linestyle="--", alpha=0.1)

    i, next_i = solution[-1] - 1, solution[0] - 1
    plt.plot([coords[i, 0], coords[next_i, 0]], [coords[i, 1], coords[next_i, 1]], c='blue', lw=1, linestyle="--", alpha=0.1)

    plt.text(coords[solution[0] - 1, 0], coords[solution[0] - 1, 1], 'Start', ha='right', va='bottom')
    plt.text(coords[solution[-1] - 1, 0], coords[solution[-1] - 1, 1], 'End', ha='right', va='bottom')

# Example coordinates (replace with your actual coordinates)
# coordinates = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])
coordinates = np.array([[1, 1], [2, 2], [3, 3], [4, 4]])

# Example adjacency matrix (replace with your actual adjacency matrix)
adjacency_matrix = np.array([[0, 10, 15, 20],
                             [5, 0, 9, 10],
                             [6, 13, 0, 12],
                             [8, 8, 9, 0]])

# Example solution path
solution_path = [1, 2, 3, 4]

# Call the function to plot the solution
plot_solution(coordinates, adjacency_matrix, solution_path)

plt.title('Optimal Path Visualization')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)
plt.show()